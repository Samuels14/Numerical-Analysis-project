INCREMENTAL_SEARCH(f, a, b, step):
    x ← a
    f_x ← f(x)
    WHILE x ≤ b DO
        next_x ← x + step
        f_next ← f(next_x)
        IF f_x * f_next < 0 THEN
            PRINT "Root in interval [", x, ",", next_x, "]"
        END IF
        x ← next_x
        f_x ← f_next
    END WHILE
--------------------------------------------
BISECTION(f, a, b, tol, max_iter):
    fa ← f(a)
    fb ← f(b)
    IF fa * fb > 0 THEN
        PRINT "No root in interval"
        RETURN
    END IF
    FOR k ← 1 TO max_iter DO
        m ← (a + b) / 2
        fm ← f(m)
        PRINT k, a, b, m, fm
        IF |fm| < tol OR (b - a)/2 < tol THEN
            RETURN m
        END IF
        IF fa * fm < 0 THEN
            b ← m
            fb ← fm
        ELSE
            a ← m
            fa ← fm
        END IF
    END FOR
    RETURN m
--------------------------------------------
FALSE_POSITION(f, a, b, tol, max_iter):
    fa ← f(a)
    fb ← f(b)
    IF fa * fb > 0 THEN
        PRINT "No root in interval"
        RETURN
    END IF
    FOR k ← 1 TO max_iter DO
        x ← (a*fb - b*fa) / (fb - fa)
        fx ← f(x)
        PRINT k, a, b, x, fx
        IF |fx| < tol THEN
            RETURN x
        END IF
        IF fa * fx < 0 THEN
            b ← x
            fb ← fx
        ELSE
            a ← x
            fa ← fx
        END IF
    END FOR
    RETURN x

--------------------------------------------
FIXED_POINT(g, x0, tol, max_iter):
    x ← x0
    FOR k ← 1 TO max_iter DO
        x_next ← g(x)
        err ← |x_next - x|
        PRINT k, x, x_next, err
        IF err < tol THEN
            RETURN x_next
        END IF
        x ← x_next
    END FOR
    RETURN x

--------------------------------------------
NEWTON(f, f', x0, tol, max_iter):
    x ← x0
    FOR k ← 1 TO max_iter DO
        fx ← f(x)
        fpx ← f'(x)
        IF fpx = 0 THEN
            PRINT "Zero derivative"
            RETURN
        END IF
        x_next ← x - fx / fpx
        err ← |x_next - x|
        PRINT k, x, fx, fpx, x_next, err
        IF err < tol THEN
            RETURN x_next
        END IF
        x ← x_next
    END FOR
    RETURN x

--------------------------------------------
SECANT(f, x0, x1, tol, max_iter):
    FOR k ← 1 TO max_iter DO
        f0 ← f(x0)
        f1 ← f(x1)
        IF f1 - f0 = 0 THEN
            PRINT "Division by zero"
            RETURN
        END IF
        x2 ← x1 - f1 * (x1 - x0) / (f1 - f0)
        err ← |x2 - x1|
        PRINT k, x0, x1, x2, err
        IF err < tol THEN
            RETURN x2
        END IF
        x0 ← x1
        x1 ← x2
    END FOR
    RETURN x1

--------------------------------------------
MULTIPLE_ROOTS(f, f', x0, m, tol, max_iter):
    x ← x0
    FOR k ← 1 TO max_iter DO
        fx ← f(x)
        fpx ← f'(x)
        IF fpx = 0 THEN
            PRINT "Zero derivative"
            RETURN
        END IF
        x_next ← x - m * fx / fpx
        err ← |x_next - x|
        PRINT k, x, fx, fpx, x_next, err
        IF err < tol THEN
            RETURN x_next
        END IF
        x ← x_next
    END FOR
    RETURN x

--------------------------------------------
GAUSSIAN_ELIMINATION(A, b, pivot_type):
    n ← number of rows
    FOR k ← 1 TO n-1 DO
        IF pivot_type = 'partial' THEN
            swap row with largest |A[i][k]|, i ≥ k
        ELSE IF pivot_type = 'total' THEN
            swap row & column with largest |A[i][j]|, i,j ≥ k
        END IF
        FOR i ← k+1 TO n DO
            factor ← A[i][k] / A[k][k]
            FOR j ← k TO n DO
                A[i][j] ← A[i][j] - factor * A[k][j]
            END FOR
            b[i] ← b[i] - factor * b[k]
        END FOR
    END FOR
    x[n] ← b[n] / A[n][n]
    FOR i ← n-1 DOWNTO 1 DO
        sum ← b[i]
        FOR j ← i+1 TO n DO
            sum ← sum - A[i][j] * x[j]
        END FOR
        x[i] ← sum / A[i][i]
    END FOR
    RETURN x
--------------------------------------------
FACTORIZACION Y RESOLUCIÓN DE SISTEMAS LINEALES
1. C11_lusimpl(A, b)
(Factorización LU simple con eliminación gaussiana)
Entrada:
 A: matriz cuadrada
 b: vector de constantes
Salida:
 x: solución del sistema
 L, U: matrices de factorización LU
Pseudocódigo:
n ← número de filas de A
L ← matriz identidad n×n
U ← matriz de ceros n×n
M ← copia de A

Para i desde 1 hasta n-1 hacer:
    Para j desde i+1 hasta n hacer:
        Si M[j, i] ≠ 0 entonces:
            L[j, i] ← M[j, i] / M[i, i]
            M[j, i:n] ← M[j, i:n] - (M[j, i] / M[i, i]) * M[i, i:n]
        Fin Si
    Fin Para
    U[i, i:n] ← M[i, i:n]
    U[i+1, i+1:n] ← M[i+1, i+1:n]
Fin Para

U[n, n] ← M[n, n]

z ← sustprgr([L | b])
x ← sustregr([U | z])
Retornar (x, L, U)

________________________________________
2. C12_lupar(A, b)
(Factorización LU con pivoteo parcial)
Entrada:
 A: matriz cuadrada
 b: vector de constantes
Salida:
 x: solución
 L, U: matrices LU
 P: matriz de permutación
Pseudocódigo:
n ← número de filas de A
L ← identidad(n)
U ← matriz de ceros(n)
P ← identidad(n)
M ← copia de A

Para i desde 1 hasta n-1 hacer:
    (max_val, pos) ← valor y posición del máximo |M[i+1:n, i]|
    Si max_val > |M[i, i]| entonces:
        Intercambiar filas i y i+pos en M y P
        Si i > 1 entonces intercambiar las mismas filas en L(,1:i-1)
    Fin Si

    Para j desde i+1 hasta n hacer:
        Si M[j, i] ≠ 0 entonces:
            L[j, i] ← M[j, i] / M[i, i]
            M[j, i:n] ← M[j, i:n] - (M[j, i] / M[i, i]) * M[i, i:n]
        Fin Si
    Fin Para

    U[i, i:n] ← M[i, i:n]
    U[i+1, i+1:n] ← M[i+1, i+1:n]
Fin Para

U[n, n] ← M[n, n]

z ← sustprgr([L | P*b])
x ← sustregr([U | z])
Retornar (x, L, U, P)

________________________________________
3. C13_Crout(A, b)
(Factorización LU método Crout)
Pseudocódigo:
n ← tamaño de A
L ← identidad(n)
U ← identidad(n)

Para i desde 1 hasta n-1 hacer:
    Para j desde i hasta n:
        L[j, i] ← A[j, i] - Σ_{k=1}^{i-1} L[j, k]*U[k, i]
    Fin Para
    Para j desde i+1 hasta n:
        U[i, j] ← (A[i, j] - Σ_{k=1}^{i-1} L[i, k]*U[k, j]) / L[i, i]
    Fin Para
Fin Para

L[n, n] ← A[n, n] - Σ_{k=1}^{n-1} L[n, k]*U[k, n]

z ← sustprgr([L | b])
x ← sustregr([U | z])
Retornar (x, L, U)

________________________________________
4. C14_Doolittle(A, b)
(Factorización LU método Doolittle)
Pseudocódigo:
n ← tamaño de A
L ← identidad(n)
U ← identidad(n)

Para i desde 1 hasta n-1 hacer:
    Para j desde i hasta n:
        U[i, j] ← A[i, j] - Σ_{k=1}^{i-1} L[i, k]*U[k, j]
    Fin Para
    Para j desde i+1 hasta n:
        L[j, i] ← (A[j, i] - Σ_{k=1}^{i-1} L[j, k]*U[k, i]) / U[i, i]
    Fin Para
Fin Para

U[n, n] ← A[n, n] - Σ_{k=1}^{n-1} L[n, k]*U[k, n]

z ← sustprgr([L | b])
x ← sustregr([U | z])
Retornar (x, L, U)

________________________________________
5. C15_Cholesky(A, b)
(Factorización Cholesky)
Pseudocódigo:
n ← tamaño de A
L ← identidad(n)
U ← identidad(n)

Para i desde 1 hasta n-1 hacer:
    L[i, i] ← √(A[i, i] - Σ_{k=1}^{i-1} L[i, k]*U[k, i])
    U[i, i] ← L[i, i]
    Para j desde i+1 hasta n:
        L[j, i] ← (A[j, i] - Σ_{k=1}^{i-1} L[j, k]*U[k, i]) / U[i, i]
        U[i, j] ← (A[i, j] - Σ_{k=1}^{i-1} L[i, k]*U[k, j]) / L[i, i]
    Fin Para
Fin Para

L[n, n] ← √(A[n, n] - Σ_{k=1}^{n-1} L[n, k]*U[k, n])
U[n, n] ← L[n, n]

z ← sustprgr([L | b])
x ← sustregr([U | z])
Retornar (x, L, U)

________________________________________
6. C16_jacobi(A, b, x0, tol, Nmax)
(Método de Jacobi)
Entrada:
 A: matriz cuadrada
 b: vector constante
 x0: vector inicial
 tol: tolerancia
 Nmax: número máximo de iteraciones
Salida:
 x: aproximación de la solución
 iter: número de iteraciones realizadas
 err: error final
Pseudocódigo:
D ← diag(diag(A))
L ← -tril(A) + D
U ← -triu(A) + D
T ← inv(D) * (L + U)
C ← inv(D) * b
xant ← x0
E ← 1000
cont ← 0

Mientras (E > tol) y (cont < Nmax) hacer:
    xact ← T * xant + C
    E ← ||xant - xact||
    xant ← xact
    cont ← cont + 1
Fin Mientras

x ← xact
iter ← cont
err ← E
Retornar (x, iter, err)

________________________________________
7. C17_gseidel(A, b, x0, tol, Nmax)
(Método de Gauss-Seidel)
Pseudocódigo:
D ← diag(diag(A))
L ← -tril(A) + D
U ← -triu(A) + D
T ← inv(D - L) * U
C ← inv(D - L) * b
xant ← x0
E ← 1000
cont ← 0

Mientras (E > tol) y (cont < Nmax) hacer:
    xact ← T * xant + C
    E ← ||xant - xact||
    xant ← xact
    cont ← cont + 1
Fin Mientras

x ← xact
iter ← cont
err ← E
Retornar (x, iter, err)

________________________________________
8. C18_sor(A, b, x0, w, tol, Nmax)
(Método SOR – Successive Over-Relaxation)
Pseudocódigo:
D ← diag(diag(A))
L ← -tril(A) + D
U ← -triu(A) + D
T ← inv(D - w*L) * ((1 - w)*D + w*U)
C ← w * inv(D - w*L) * b
xant ← x0
E ← 1000
cont ← 0

Mientras (E > tol) y (cont < Nmax) hacer:
    xact ← T * xant + C
    E ← ||xant - xact||
    xant ← xact
    cont ← cont + 1
Fin Mientras

x ← xact
iter ← cont
err ← E
Retornar (x, iter, err)

________________________________________
9. C19_vandermonde(X, Y)
(Interpolación usando matriz de Vandermonde)
Pseudocódigo:
n ← longitud(X)
A ← matriz de ceros n×n

Para i desde 1 hasta n hacer:
    A[:, i] ← X^(n - i)
Fin Para

Coef ← resolver(A, Y)
Retornar Coef

________________________________________
10. C20_difdivididas(X, Y)
(Interpolación de Newton – diferencias divididas)
Pseudocódigo:
n ← longitud(X)
D ← matriz de ceros n×n
D[:,1] ← Y

Para i desde 2 hasta n hacer:
    Para j desde i hasta n hacer:
        D[j, i] ← (D[j, i-1] - D[j-1, i-1]) / (X[j] - X[j-i+1])
    Fin Para
Fin Para

Coef ← diagonal(D)
Retornar Coef

________________________________________
11. C21_lagrange(X, Y)
(Interpolación por el método de Lagrange)
Pseudocódigo:
n ← longitud(X)
L ← matriz de ceros n×n

Para i desde 1 hasta n hacer:
    aux0 ← X sin X[i]
    aux ← [1, -aux0[1]]
    Para j desde 2 hasta n-1 hacer:
        aux ← conv(aux, [1, -aux0[j]])    // Producto polinómico
    Fin Para
    L[i, :] ← aux / evaluar(aux, X[i])
Fin Para

Coef ← Y * L
Retornar (L, Coef)

________________________________________
12. C22_trazlin(X, Y)
(Spline lineal)
Pseudocódigo:
n ← longitud(X)
m ← 2*(n-1)
A ← matriz de ceros m×m
b ← vector de ceros m
Coef ← matriz de ceros (n-1)×2

// Condiciones de interpolación
Para i desde 1 hasta n-1 hacer:
    A[i+1, (2*i-1):(2*i)] ← [X[i+1], 1]
    b[i+1] ← Y[i+1]
Fin Para
A[1, 1:2] ← [X[1], 1]
b[1] ← Y[1]

// Condiciones de continuidad
Para i desde 2 hasta n-1 hacer:
    A[n-1+i, (2*i-3):(2*i)] ← [X[i], 1, -X[i], -1]
    b[n-1+i] ← 0
Fin Para

Saux ← resolver(A, b)
Para i desde 1 hasta n-1 hacer:
    Coef[i, :] ← Saux[(2*i-1):(2*i)]
Fin Para
Retornar Coef

________________________________________
13. C23_trazcuad(X, Y)
(Spline cuadrático)
Pseudocódigo:
n ← longitud(X)
m ← 3*(n-1)
A ← ceros(m, m)
b ← ceros(m)
Coef ← ceros(n-1, 3)

// Condiciones de interpolación
Para i desde 1 hasta n-1 hacer:
    A[i+1, (3*i-2):(3*i)] ← [X[i+1]^2, X[i+1], 1]
    b[i+1] ← Y[i+1]
Fin Para
A[1, 1:3] ← [X[1]^2, X[1], 1]
b[1] ← Y[1]

// Continuidad
Para i desde 2 hasta n-1 hacer:
    A[n-1+i, (3*i-5):(3*i)] ← [X[i]^2, X[i], 1, -X[i]^2, -X[i], -1]
Fin Para

// Suavidad
Para i desde 2 hasta n-1 hacer:
    A[2*n-3+i, (3*i-5):(3*i)] ← [2*X[i], 1, 0, -2*X[i], -1, 0]
Fin Para

// Condición de frontera
A[m, 1] ← 2
b[m] ← 0

Saux ← resolver(A, b)
Para i desde 1 hasta n-1 hacer:
    Coef[i, :] ← Saux[(3*i-2):(3*i)]
Fin Para
Retornar Coef

________________________________________
14. C24_trazcub(X, Y)
(Spline cúbico)
Pseudocódigo:
n ← longitud(X)
m ← 4*(n-1)
A ← ceros(m, m)
b ← ceros(m)
Coef ← ceros(n-1, 4)

// Condiciones de interpolación
Para i desde 1 hasta n-1 hacer:
    A[i+1, (4*i-3):(4*i)] ← [X[i+1]^3, X[i+1]^2, X[i+1], 1]
    b[i+1] ← Y[i+1]
Fin Para
A[1, 1:4] ← [X[1]^3, X[1]^2, X[1], 1]
b[1] ← Y[1]

// Continuidad
Para i desde 2 hasta n-1 hacer:
    A[n-1+i, (4*i-7):(4*i)] ← [X[i]^3, X[i]^2, X[i], 1, -X[i]^3, -X[i]^2, -X[i], -1]
Fin Para

// Suavidad
Para i desde 2 hasta n-1 hacer:
    A[2*n-3+i, (4*i-7):(4*i)] ← [3*X[i]^2, 2*X[i], 1, 0, -3*X[i]^2, -2*X[i], -1, 0]
Fin Para

// Concavidad
Para i desde 2 hasta n-1 hacer:
    A[3*n-5+i, (4*i-7):(4*i)] ← [6*X[i], 2, 0, 0, -6*X[i], -2, 0, 0]
Fin Para

// Condiciones de frontera
A[m-1, 1:2] ← [6*X[1], 2]
A[m, m-3:m-2] ← [6*X[n], 2]
b[m-1] ← 0
b[m] ← 0

Saux ← resolver(A, b)
Para i desde 1 hasta n-1 hacer:
    Coef[i, :] ← Saux[(4*i-3):(4*i)]
Fin Para
Retornar Coef.

------------------------------------

AUXILIARES
1. sustregr(M)
(Sustitución regresiva para matriz aumentada [U|b])
Entrada:
 M = matriz aumentada [U|b], con U triangular superior.
Salida:
 x = vector solución.
Pseudocódigo:
n ← número de filas de M
x ← vector de ceros de tamaño n

x[n] ← M[n, n+1] / M[n, n]

Para i desde n-1 hasta 1 hacer:
    aux ← [1, x[i+1 ... n]]
    aux1 ← [M[i, n+1], -M[i, i+1 ... n]]
    x[i] ← (aux ⋅ aux1) / M[i, i]
Fin Para

Retornar x

________________________________________
2. sustprgr(M)
(Sustitución progresiva para matriz aumentada [L|b])
Entrada:
 M = matriz aumentada [L|b], con L triangular inferior.
Salida:
 x = vector solución.
Pseudocódigo:
n ← número de filas de M
x ← vector de ceros de tamaño n

x[1] ← M[1, n+1] / M[1, 1]

Para i desde 2 hasta n hacer:
    aux ← [1, x[1 ... i-1]]
    aux1 ← [M[i, n+1], -M[i, 1 ... i-1]]
    x[i] ← (aux ⋅ aux1) / M[i, i]
Fin Para

Retornar x

