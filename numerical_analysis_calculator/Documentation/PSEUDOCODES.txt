INCREMENTAL_SEARCH(f, a, b, step):
    x ← a
    f_x ← f(x)
    WHILE x ≤ b DO
        next_x ← x + step
        f_next ← f(next_x)
        IF f_x * f_next < 0 THEN
            PRINT "Root in interval [", x, ",", next_x, "]"
        END IF
        x ← next_x
        f_x ← f_next
    END WHILE
--------------------------------------------
BISECTION(f, a, b, tol, max_iter):
    fa ← f(a)
    fb ← f(b)
    IF fa * fb > 0 THEN
        PRINT "No root in interval"
        RETURN
    END IF
    FOR k ← 1 TO max_iter DO
        m ← (a + b) / 2
        fm ← f(m)
        PRINT k, a, b, m, fm
        IF |fm| < tol OR (b - a)/2 < tol THEN
            RETURN m
        END IF
        IF fa * fm < 0 THEN
            b ← m
            fb ← fm
        ELSE
            a ← m
            fa ← fm
        END IF
    END FOR
    RETURN m
--------------------------------------------
FALSE_POSITION(f, a, b, tol, max_iter):
    fa ← f(a)
    fb ← f(b)
    IF fa * fb > 0 THEN
        PRINT "No root in interval"
        RETURN
    END IF
    FOR k ← 1 TO max_iter DO
        x ← (a*fb - b*fa) / (fb - fa)
        fx ← f(x)
        PRINT k, a, b, x, fx
        IF |fx| < tol THEN
            RETURN x
        END IF
        IF fa * fx < 0 THEN
            b ← x
            fb ← fx
        ELSE
            a ← x
            fa ← fx
        END IF
    END FOR
    RETURN x

--------------------------------------------
FIXED_POINT(g, x0, tol, max_iter):
    x ← x0
    FOR k ← 1 TO max_iter DO
        x_next ← g(x)
        err ← |x_next - x|
        PRINT k, x, x_next, err
        IF err < tol THEN
            RETURN x_next
        END IF
        x ← x_next
    END FOR
    RETURN x

--------------------------------------------
NEWTON(f, f', x0, tol, max_iter):
    x ← x0
    FOR k ← 1 TO max_iter DO
        fx ← f(x)
        fpx ← f'(x)
        IF fpx = 0 THEN
            PRINT "Zero derivative"
            RETURN
        END IF
        x_next ← x - fx / fpx
        err ← |x_next - x|
        PRINT k, x, fx, fpx, x_next, err
        IF err < tol THEN
            RETURN x_next
        END IF
        x ← x_next
    END FOR
    RETURN x

--------------------------------------------
SECANT(f, x0, x1, tol, max_iter):
    FOR k ← 1 TO max_iter DO
        f0 ← f(x0)
        f1 ← f(x1)
        IF f1 - f0 = 0 THEN
            PRINT "Division by zero"
            RETURN
        END IF
        x2 ← x1 - f1 * (x1 - x0) / (f1 - f0)
        err ← |x2 - x1|
        PRINT k, x0, x1, x2, err
        IF err < tol THEN
            RETURN x2
        END IF
        x0 ← x1
        x1 ← x2
    END FOR
    RETURN x1

--------------------------------------------
MULTIPLE_ROOTS(f, f', x0, m, tol, max_iter):
    x ← x0
    FOR k ← 1 TO max_iter DO
        fx ← f(x)
        fpx ← f'(x)
        IF fpx = 0 THEN
            PRINT "Zero derivative"
            RETURN
        END IF
        x_next ← x - m * fx / fpx
        err ← |x_next - x|
        PRINT k, x, fx, fpx, x_next, err
        IF err < tol THEN
            RETURN x_next
        END IF
        x ← x_next
    END FOR
    RETURN x

--------------------------------------------
GAUSSIAN_ELIMINATION(A, b, pivot_type):
    n ← number of rows
    FOR k ← 1 TO n-1 DO
        IF pivot_type = 'partial' THEN
            swap row with largest |A[i][k]|, i ≥ k
        ELSE IF pivot_type = 'total' THEN
            swap row & column with largest |A[i][j]|, i,j ≥ k
        END IF
        FOR i ← k+1 TO n DO
            factor ← A[i][k] / A[k][k]
            FOR j ← k TO n DO
                A[i][j] ← A[i][j] - factor * A[k][j]
            END FOR
            b[i] ← b[i] - factor * b[k]
        END FOR
    END FOR
    x[n] ← b[n] / A[n][n]
    FOR i ← n-1 DOWNTO 1 DO
        sum ← b[i]
        FOR j ← i+1 TO n DO
            sum ← sum - A[i][j] * x[j]
        END FOR
        x[i] ← sum / A[i][i]
    END FOR
    RETURN x

